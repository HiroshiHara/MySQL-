# 用語メモ
# データ操作言語(DML)
# データ定義言語(DDL)
# データ制御言語(DCL)

# データ型
# 数値
# 基本はintでOK
tinyint, smallint, mediumint, int, bigint

# 浮動少数型, 固定少数型
# 浮動少数型は基本はdoubleでOK, decimal(numeric)は指定した桁数の精度を保証
float, double
decimal, numeric

# 文字列(シングルクォートで囲む)
# 固定長文字列の空きは半角スペースで, 固定長バイナリは0で埋められる
char, varchar, text, binary, varbinary, blob, enum, set

# 日付時刻(シングルクォートで囲む)
# 日付はYYYYMMDD形式で指定, デリミタ(/, -, ^, @など)があれば月や日の頭の0を省略可
# 時刻は'D HH:MM:SS'や'HH:MM:SS', 'HH:MM:SS.xxxxxx'などで指定, デリミタは(:, +, *, ^)
# 日付時刻でtimestampは時刻をグリニッジ標準時に自動変換するので、時差を考慮する場合は使用
# 日付と時刻の区切りは半角スペースか'T'
date, time, datetime, timestamp, year

# その他
geometry, point, linestring, polygon

# データの抽出
select カラム名 from テーブル名;

# データの絞り込み
select カラム名 from テーブル名 where 条件式;

# データの挿入
# カラム名と挿入値の並びは一致させること
insert into テーブル名 (カラム名①, カラム名②, ...)
values (挿入値①, 挿入値②, ...);

# データの更新
# insert文では二重登録などエラーの恐れがある
# where句でどのレコードを更新するか指定する
update テーブル名 set カラム名 = 値
where 主キー = 値;

# update文で計算式を用いる
update テーブル名 set カラム名 = 計算式;

# データの削除
# 条件式を指定しないと全レコードの削除となる。
delete from テーブル名 where = 条件式;

# NULL値検索
# where hiredate = null でないことに注意
ex. select * from emp where hiredate is null

# 比較演算子
# not equal は <> もしくは != で表す
# between X and Y ... X以上Y以下の範囲
# not between A and B ... A以上B以下の範囲でない
# in (A, B, C, ...)列挙した値のいずれか
# not in 列挙した値のどれでもない
# in(not in)で検索できるのは完全一致のみ
# like 文字列がパターンに合致する
# not like 文字列化がパターンに合致しない
# % ... 0文字以上の任意の文字列 _ ... 任意の1文字
# <=> null安全等価 =と機能は同じだが、両方のオペランドがnullであれば1, 片方がnullなら0が返される。
# is null nullである
# is not null nullでない

# 論理演算子
# XOR, && || ! はMySQLの方言なので使用しないほうが無難
# 優先順位は not > and > or
# where X in (not 'A', 'B', 'C')のように、in句のカッコの中でnotを使用できる

# 前提：関数はselect句だけでなく、where句にも使用できる

# 数値関数
# floor()... 引数以下で最大の整数値を返す(小数点切り捨て)
# ceiling(), ceil()... 引数以下で最小の整数値を返す(小数点切り上げ)
# round()... 引数を四捨五入する, 第二引数で小数点第何位まで丸めるか指定可
# trauncate()... 指定された小数点以下の桁数に切り捨て
# exp()... 引数を累乗する
# pow()... 引数を指定した指数で累乗する
# sqrt()... 引数の平方根を返す
# rand()... ランダムな浮動小数点値を返す
select round(rand * 10) で0~10のランダムな整数を取得できる
乱数取得のテンプレートは floor(rand() * (最大値 - 最小値) + 最小値)
# abs()... 引数の絶対値を返す

# 文字列関数
# concat()... 文字列を連結する
ex. select concat(state, address) from jusho;
# concat_ws()... 区切り文字を指定して文字列を連結する
# replace()... 文字列を置換する
ex. select replace(company, '社', '株式会社') from uriage;
# insert()... 文字列を挿入する
# char_length()... 文字列の長さを返す
# length()... 文字列のバイト数を返す
# left()... 左端から引数分の文字列を返す
# right()... 右端から引数分の文字列を返す
# substring()... 指定した箇所から引数分の文字列を返す
# (l, r)trim()... 両端の空白を削除する
# (l, r)pad()... 指定した桁数で左右から文字を埋める
# space()... 指定した数の空白で構成された空文字を返す
# lower(), upper()... 大文字小文字変換
# format()... 三桁ごとにカンマ区切り, 小数点以下表示
ex. select format(charge, 2) from uriage;
# strcmp()... 文字列比較
# 

# 日付および時間関数
# now()... 現在時刻取得
# sysdate()... クエリ実行時刻取得
# year(), month(), week(), day(), hour()... 年月日時分秒を取得
# dayname()... 曜日を英語で取得
# date_format()
ex. date_format(salesdate, '%Y年%m月%d日')

# 絞り込み
# distinct... 重複の除去(distinctはselect文の直後でしか機能しない)
ex. select distinct company from uriage where charge >= 100000;

# order by カラム名... ascで昇順, descで降順
# from テーブル名の直後かwhere句の後に記述
ex. select distinct company from uriage where charge >= 100000 order by charge desc;

# limit 件数 (limit 指定箇所, 件数)
# select構文でしか使えず、order by の直後に記述する。order by が無くとも書けるが無意味
ex. select company, charge from uriage where charge >= 100000 order by charge asc limit 5, 4;(5番目に少ないものから4件)

# 集約関数
# where句に記述することは出来ない
# avg()... 平均値を取得
ex. select floor(avg(charge)) from uriage where charge >= 100000;
# count()... レコードの件数を取得
# group_concat()... レコードをカンマ区切りで連結した値を取得
# max(), min()... 最大値、最小値を取得
# sum()... 合計値の取得

# group by
# 指定したカラムごとに集計
# group byで指定するカラムと、select文で指定するカラムは(集計関数以外)一致させる
ex. select company, avg(charge) from uriage group by company;
# 関数で取得・整形したカラムで集計したいときは、ASで名前をつけて集計する。
ex. select date_format(salesdate, '%Y%m') as month, avg(charge) from uriage group by month;
# group byで集計した結果を並び替えたいときは、order by句は文末につける
ex. select company, sum(charge) as sum from uriage group by company order by sum desc;

# having
# group byで集計した結果を条件で絞り込む
# (集計後、さらに合計値が600000以上のレコードのみを抽出)
ex. select company, sum(charge) as sum from uriage group by company having sum >= 600000 order by sum desc;
# whereは集計前に対して条件で絞り込む
# (chargeが100000のレコードのみを対象に平均を取得、companyで集計)
ex. select company, avg(charge) as avg from uriage where charge >= 100000 group by company;
# (chargeが100000のレコードのみを対象に平均を取得、companyで集計の後、平均が200000以上のレコードのみを抽出)
ex. select company, avg(charge) as avg from uriage where charge >= 100000 group by company having avg >= 200000;

# テーブル結合

# union(和集合)
# テーブル同士をそのまま結合
# 結合するテーブルはカラム数と対応するカラムの型は一致していなければならない(列名は左オペランドの値が適用)
# union オプション名(all/distinct)で重複するレコードを残すか削除できる
ex. select * from tableA union distinct select * from tableB;

# inner join(内部結合)
# テーブル同士、あるカラムの値が共通するレコードのみを結合する(カラム数は増える、レコード数は減る)
# 基本構文... select * from テーブル名 inner join テーブル名 on テーブル名.カラム名 = テーブル名.カラム名;
ex. select * from tableA inner join tableB tableA.columnA = tableB.columnA;
# select文でカラム名を指定する際、両方のテーブルに存在するカラム名を指定するときはテーブル名.カラム名の形で指定する
ex. select jusho.company, jusho.state, charge, salesdate from jusho inner join uriage on jusho.company = uriage.company;
# where句でも内部結合できる
ex. select * from table1, table2 where table1.columnA = table2.columnB;
# 内部結合で得られたテーブルを集計する
ex. select jusho.company, avg(charge) as avg from jusho inner join uriage on jusho.company = uriage.company group by jusho.company;

# outer join(外部結合)
# 結合元のテーブル(主テーブル)と結合先のテーブル(副テーブル)を結合
# あるカラムの値が共通するレコードは内部結合と同様に結合される
# 主テーブルにあって副テーブルにないものはnull値が入る
# 副テーブルにあって主テーブルにないものは破棄される
# 主テーブルを全て残す場合は左結合、副テーブルを全て残す場合は右結合
# 基本構文... select * from テーブル名 left(right) join テーブル名 on テーブル名.カラム名 = テーブル名.カラム名

# cross join(交差結合)
# レコードとレコードを総当たりで結合する(テーブルAのレコード数 * テーブルBのレコード数 = 結合結果のレコード数)

# サブクエリ
# select, update, deleteのwhere句におけるリテラルで使用、またはupdateやinsert intoにおける値設定に使用
# 基本構文... select * from テーブル名 where テーブル名.列名 演算子 (select 列名 from テーブル名 ... );
ex. select * from uriage where charge >= (select avg(charge) from uriage);
# (全体平均売上より平均売上が大きい会社を抽出)
ex. 
select uriage.company, floor(avg(charge)) as avg 
from uriage inner join jusho 
on uriage.company = jusho.company 
group by uriage.company 
having avg >= (select avg(charge) from uriage);

# スカラサブクエリ
# 単一値(一列かつ一行のみ)を返すサブクエリ
# >, <, = などの演算子で比較する
ex.
select * from uriage
where charge >= (select avg(charge) from uriage);

# カラムクエリ
# カラムは一つだが、複数レコードを返す可能性のあるクエリ
# 比較演算子で比較できず、inなどを使用して比較する
ex.
select * from uriage
where company in (select company from jusho where state = '東京都');

# 行クエリ
# 1レコードしか返さないが、複数カラムを返す可能性のあるクエリ

# テーブルクエリ
# 複数カラム、かつ複数レコードを返す可能性のあるクエリ

# exists(not exists)
# サブクエリの戻り値があるかどうかを調べる演算子, where句で使用する。
# exists演算子で利用するサブクエリは、レコードが存在するかどうかを調べることが目的のため、抽出するカラムは何でもいい。
# 慣例的に * で指定する
ex. 
select * from jusho
where exists
(select * from uriage
inner join jusho on uriage.company = jusho.company
where salesdate >= '2017-09-01'
and salesdate <= '2017-09-30');